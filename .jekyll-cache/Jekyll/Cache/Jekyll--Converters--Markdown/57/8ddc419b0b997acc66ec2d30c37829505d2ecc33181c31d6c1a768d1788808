I"Z<p>When creating certain scripts it is nice to know if the current user is an administrator to the workstation or not. This can be done in a few ways, Powershell and also .NET.</p>

<p>First we can use ADSI to query the computer and get the objects found in group specified. In this example we query the administrators group using the current user, then if the current user is in the group, we have a match.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">$</span><span class="nn">env</span><span class="p">:</span><span class="nv">USERNAME</span><span class="p">;</span><span class="w">
</span><span class="nv">$group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Administrators"</span><span class="p">;</span><span class="w">
</span><span class="nv">$groupObj</span><span class="w"> </span><span class="o">=</span><span class="p">[</span><span class="n">ADSI</span><span class="p">]</span><span class="s2">"WinNT://./</span><span class="nv">$group</span><span class="s2">,group"</span><span class="w">
</span><span class="nv">$membersObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">@(</span><span class="nv">$groupObj</span><span class="err">.psbase.Invoke(</span><span class="s2">"Members"</span><span class="p">))</span><span class="w">
</span><span class="nv">$members</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nv">$membersObj</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kr">foreach</span><span class="w"> </span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">GetType</span><span class="p">()</span><span class="o">.</span><span class="nf">InvokeMember</span><span class="p">(</span><span class="s2">"Name"</span><span class="p">,</span><span class="w"> </span><span class="s1">'GetProperty'</span><span class="p">,</span><span class="w"> </span><span class="bp">$null</span><span class="p">,</span><span class="w"> </span><span class="bp">$_</span><span class="p">,</span><span class="w"> </span><span class="bp">$null</span><span class="p">)})</span><span class="w">

</span><span class="kr">If</span><span class="w"> </span><span class="p">(</span><span class="nv">$members</span><span class="w"> </span><span class="o">-contains</span><span class="w"> </span><span class="nv">$user</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">Write-Host</span><span class="w"> </span><span class="nv">$user</span><span class="w"> </span><span class="nt">-foregroundcolor</span><span class="w"> </span><span class="s2">"Red"</span><span class="w"> </span><span class="nt">-NoNewLine</span><span class="p">;</span><span class="w"> </span><span class="n">Write-Host</span><span class="w"> </span><span class="s2">" exists in the local group </span><span class="nv">$group</span><span class="s2">"</span><span class="w">
</span><span class="p">}</span><span class="w"> </span><span class="kr">Else</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">Write-Host</span><span class="w"> </span><span class="s2">"</span><span class="nv">$user</span><span class="s2"> not exists in the local group </span><span class="nv">$group</span><span class="s2">"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Now to speed up that process we can harness .NET classes in PowerShell. We will use the [Security.Principal.WindowsPrincipal] class.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">([</span><span class="n">Security.Principal.WindowsPrincipal</span><span class="p">][</span><span class="n">Security.Principal.WindowsIdentity</span><span class="p">]::</span><span class="n">GetCurrent</span><span class="p">())</span><span class="o">.</span><span class="nf">IsInRole</span><span class="p">([</span><span class="n">Security.Principal.WindowsBuiltInRole</span><span class="p">]::</span><span class="nx">Administrator</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>From here we get the current users identity and check if they are in the role of Administrator. This is a lot quicker and faster as well since it is in one line and can be used in a quicker manner to restart the script as an administrator.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">([</span><span class="n">Security.Principal.WindowsPrincipal</span><span class="p">][</span><span class="n">Security.Principal.WindowsIdentity</span><span class="p">]::</span><span class="n">GetCurrent</span><span class="p">())</span><span class="o">.</span><span class="nf">IsInRole</span><span class="p">([</span><span class="n">Security.Principal.WindowsBuiltInRole</span><span class="p">]</span><span class="w"> </span><span class="s2">"Administrator"</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Start-Process</span><span class="w"> </span><span class="nx">powershell.exe</span><span class="w"> </span><span class="s2">"-NoProfile -ExecutionPolicy Bypass -File </span><span class="se">`"</span><span class="bp">$PSCommandPath</span><span class="se">`"</span><span class="s2">"</span><span class="w"> </span><span class="nt">-Verb</span><span class="w"> </span><span class="nx">RunAs</span><span class="p">;</span><span class="w"> </span><span class="kr">exit</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>To run a PowerShell script and get around the Execution Policy, we can start PowerShell, specify the execution policy and specify the PowerShell script we want to run.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PowerShell.exe</span><span class="w"> </span><span class="nt">-NoProfile</span><span class="w"> </span><span class="nt">-Command</span><span class="w"> </span><span class="s2">"&amp; {Start-Process PowerShell.exe -ArgumentList '-NoProfile -ExecutionPolicy Bypass -File ""%~dp0Server_Setup.ps1""' -Verb RunAs}"</span><span class="w">
</span></code></pre></div></div>
:ET